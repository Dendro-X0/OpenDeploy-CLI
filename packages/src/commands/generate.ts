import { Command } from 'commander'
import { stat, writeFile } from 'node:fs/promises'
import { join } from 'node:path'
import { logger, isJsonMode } from '../utils/logger'
import { detectApp } from '../core/detectors/auto'
import { loadProvider } from '../core/provider-system/provider'

interface GenerateOptions { readonly overwrite?: boolean; readonly json?: boolean; readonly nextOnPages?: boolean }

/**
 * Register the `generate` command which emits provider-specific config files.
 */
export function registerGenerateCommand(program: Command): void {
  program
    .command('generate')
    .description('Generate configuration files for the detected app (Vercel/Cloudflare) or Turborepo pipeline')
    .argument('<provider>', 'Target: vercel | cloudflare | turbo')
    .option('--overwrite', 'Overwrite existing files')
    .option('--json', 'Output JSON with generated file path')
    .option('--next-on-pages', 'For Cloudflare: scaffold wrangler.toml configured for Next on Pages')
    .action(async (provider: string, opts: GenerateOptions): Promise<void> => {
      const cwd: string = process.cwd()
      try {
        const jsonMode: boolean = isJsonMode(opts.json)
        if (jsonMode) logger.setJsonOnly(true)
        const detection = await detectApp({ cwd })
        if (provider === 'vercel') {
          const plugin = await loadProvider('vercel')
          const writtenPath: string = await plugin.generateConfig({ detection, cwd, overwrite: opts.overwrite === true })
          if (jsonMode) {
            const summary = { ok: true, action: 'generate' as const, provider: 'vercel' as const, path: writtenPath, final: true }
            logger.jsonPrint(summary)
            return
          }
          logger.success(`Generated Vercel config at ${writtenPath}`)
          return
        }
        if (provider === 'cloudflare') {
          // If --next-on-pages, scaffold wrangler.toml for Next on Pages; else minimal provider config
          if (opts.nextOnPages === true) {
            const path: string = join(cwd, 'wrangler.toml')
            const exists = async (): Promise<boolean> => { try { const s = await stat(path); return s.isFile() } catch { return false } }
            if (opts.overwrite === true || !(await exists())) {
              const base = cwd.replace(/\\/g, '/').split('/').filter(Boolean).pop() || 'site'
              const name = base.toLowerCase().replace(/[^a-z0-9-]/g, '-').replace(/--+/g, '-').replace(/^-+|-+$/g, '') || 'site'
              const body = `# Auto-generated by OpenDeploy CLI (Cloudflare Pages â€” Next on Pages)\n# Install the builder:\n#   pnpm add -D @cloudflare/next-on-pages\n# Build locally:\n#   npx @cloudflare/next-on-pages@1\n# Deploy locally:\n#   wrangler pages deploy .vercel/output/static --project-name ${name}\nname = "${name}"\npages_build_output_dir = ".vercel/output/static"\npages_functions_directory = ".vercel/output/functions"\ncompatibility_date = "2024-01-01"\n`
              await writeFile(path, body, 'utf8')
            }
            if (jsonMode) {
              logger.jsonPrint({ ok: true, action: 'generate' as const, provider: 'cloudflare' as const, mode: 'next-on-pages' as const, path, final: true })
              return
            }
            logger.success('Generated Cloudflare wrangler.toml for Next on Pages')
            logger.note('Install: pnpm add -D @cloudflare/next-on-pages')
            logger.note('Build:   npx @cloudflare/next-on-pages@1')
            logger.note('Deploy:  wrangler pages deploy .vercel/output/static')
            return
          }
          // Minimal static Pages config via provider
          const plugin = await loadProvider('cloudflare')
          const writtenPath: string = await plugin.generateConfig({ detection, cwd, overwrite: opts.overwrite === true })
          if (jsonMode) {
            logger.jsonPrint({ ok: true, action: 'generate' as const, provider: 'cloudflare' as const, path: writtenPath, final: true })
            return
          }
          logger.success(`Generated Cloudflare config at ${writtenPath}`)
          return
        }
        if (provider === 'netlify') {
          logger.error('Netlify is not supported by OpenDeploy. Please use the official Netlify CLI.')
          process.exitCode = 1
          return
        }
        if (provider === 'turbo') {
          const path: string = join(cwd, 'turbo.json')
          const exists = async (): Promise<boolean> => { try { const s = await stat(path); return s.isFile() } catch { return false } }
          if (opts.overwrite === true || !(await exists())) {
            const turbo = {
              tasks: {
                build: {
                  dependsOn: ['^build'],
                  outputs: ['.next/**', '!.next/cache/**', 'dist/**']
                }
              }
            }
            await writeFile(path, `${JSON.stringify(turbo, null, 2)}\n`, 'utf8')
          }
          if (jsonMode) {
            logger.jsonPrint({ ok: true, action: 'generate' as const, provider: 'turbo' as const, path, final: true })
            return
          }
          logger.success(`Generated Turborepo config at ${path}`)
          return
        }
        logger.error(`Unknown provider: ${provider}`)
        process.exitCode = 1
      } catch (err) {
        const message: string = err instanceof Error ? err.message : String(err)
        logger.error(message)
        process.exitCode = 1
      }
    })
}
