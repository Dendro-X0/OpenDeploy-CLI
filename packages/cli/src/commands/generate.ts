import { Command } from 'commander'
import { stat, writeFile } from 'node:fs/promises'
import { join } from 'node:path'
import { logger, isJsonMode } from '../utils/logger'
import { detectApp } from '../core/detectors/auto'
import { loadProvider } from '../core/provider-system/provider'
import { resolveAppPath } from '../core/detectors/apps'

interface GenerateOptions { readonly overwrite?: boolean; readonly json?: boolean; readonly nextOnPages?: boolean; readonly reusable?: boolean; readonly app?: string; readonly projectName?: string }

/**
 * Register the `generate` command which emits provider-specific config files.
 */
export function registerGenerateCommand(program: Command): void {
  program
    .command('generate')
    .description('Generate configuration files for the detected app (Vercel/Cloudflare/GitHub Pages) or Turborepo pipeline')
    .argument('<provider>', 'Target: vercel | cloudflare | github | turbo')
    .option('--overwrite', 'Overwrite existing files')
    .option('--json', 'Output JSON with generated file path')
    .option('--next-on-pages', 'For Cloudflare: scaffold wrangler.toml configured for Next on Pages')
    .option('--reusable', 'Generate a per-app caller workflow that uses a reusable workflow')
    .option('--app <path>', 'App path to use in reusable workflow (defaults to auto-detected)')
    .option('--project-name <name>', 'Cloudflare Pages project name for reusable workflow')
    .action(async (provider: string, opts: GenerateOptions): Promise<void> => {
      const cwd: string = process.cwd()
      try {
        const jsonMode: boolean = isJsonMode(opts.json)
        if (jsonMode) logger.setJsonOnly(true)
        const detection = await detectApp({ cwd })
        if (provider === 'vercel') {
          const plugin = await loadProvider('vercel')
          const writtenPath: string = await plugin.generateConfig({ detection, cwd, overwrite: opts.overwrite === true })
          if (jsonMode) {
            const summary = { ok: true, action: 'generate' as const, provider: 'vercel' as const, path: writtenPath, final: true }
            logger.jsonPrint(summary)
            return
          }
          logger.success(`Generated Vercel config at ${writtenPath}`)
          return
        }
        if (provider === 'cloudflare') {
          // If --next-on-pages, scaffold wrangler.toml for Next on Pages; else minimal provider config
          if (opts.nextOnPages === true) {
            const path: string = join(cwd, 'wrangler.toml')
            const exists = async (): Promise<boolean> => { try { const s = await stat(path); return s.isFile() } catch { return false } }
            if (opts.overwrite === true || !(await exists())) {
              const base = cwd.replace(/\\/g, '/').split('/').filter(Boolean).pop() || 'site'
              const name = base.toLowerCase().replace(/[^a-z0-9-]/g, '-').replace(/--+/g, '-').replace(/^-+|-+$/g, '') || 'site'
              const body = `# Auto-generated by OpenDeploy CLI (Cloudflare Pages — Next on Pages)\n# Install the builder:\n#   pnpm add -D @cloudflare/next-on-pages\n# Build locally:\n#   npx @cloudflare/next-on-pages@1\n# Deploy locally:\n#   wrangler pages deploy .vercel/output/static --project-name ${name}\nname = "${name}"\npages_build_output_dir = ".vercel/output/static"\npages_functions_directory = ".vercel/output/functions"\ncompatibility_date = "2024-01-01"\n`
              await writeFile(path, body, 'utf8')
            }
            if (jsonMode) {
              logger.jsonPrint({ ok: true, action: 'generate' as const, provider: 'cloudflare' as const, mode: 'next-on-pages' as const, path, final: true })
              return
            }
            logger.success('Generated Cloudflare wrangler.toml for Next on Pages')
            logger.note('Install: pnpm add -D @cloudflare/next-on-pages')
            logger.note('Build:   npx @cloudflare/next-on-pages@1')
            logger.note('Deploy:  wrangler pages deploy .vercel/output/static')
            return
          }
          // Reusable per-app caller workflow
          if (opts.reusable === true) {
            // Determine app_path
            let appPath: string = opts.app && opts.app.length > 0 ? opts.app : ''
            if (!appPath) {
              const resolved = await resolveAppPath({ cwd, ci: true })
              appPath = resolved.path === cwd ? '.' : resolved.path.replace(cwd + (cwd.endsWith('\\') || cwd.endsWith('/') ? '' : (process.platform === 'win32' ? '\\' : '/')), '')
              appPath = appPath.replace(/\\/g, '/')
            }
            // Determine project name
            const slugify = (s: string): string => s.toLowerCase().replace(/[^a-z0-9-]/g, '-').replace(/--+/g, '-').replace(/^-+|-+$/g, '')
            const projName: string = opts.projectName && opts.projectName.length > 0 ? opts.projectName : slugify((appPath === '.' ? cwd : appPath).split('/').filter(Boolean).pop() || 'site')
            const relDir = '.github/workflows'
            const file = join(cwd, relDir, 'deploy-app-cloudflare.yml')
            try { await (await import('node:fs/promises')).mkdir(join(cwd, relDir), { recursive: true }) } catch { /* ignore */ }
            const body = `name: Deploy App (Cloudflare Pages)\n\n` +
`on:\n` +
`  push:\n` +
`    branches: [ main ]\n` +
`  workflow_dispatch:\n\n` +
`jobs:\n` +
`  deploy:\n` +
`    uses: ./.github/workflows/_reusable-cloudflare-pages.yml\n` +
`    with:\n` +
`      app_path: ${appPath}\n` +
`      project_name: ${projName}\n`
            await writeFile(file, body, 'utf8')
            if (jsonMode) { logger.jsonPrint({ ok: true, action: 'generate', provider: 'cloudflare', mode: 'reusable', path: file, app_path: appPath, project_name: projName, final: true }); return }
            logger.success(`Generated Cloudflare per-app workflow at ${file}`)
            logger.note(`Project: ${projName} | App: ${appPath}`)
            return
          }
          // Minimal static Pages config via provider
          const plugin = await loadProvider('cloudflare')
          const writtenPath: string = await plugin.generateConfig({ detection, cwd, overwrite: opts.overwrite === true })
          if (jsonMode) {
            logger.jsonPrint({ ok: true, action: 'generate' as const, provider: 'cloudflare' as const, path: writtenPath, final: true })
            return
          }
          logger.success(`Generated Cloudflare config at ${writtenPath}`)
          return
        }
        if (provider === 'github') {
          // Scaffold GitHub Pages workflow
          const relDir = '.github/workflows'
          const dir = join(cwd, relDir)
          try { await (await import('node:fs/promises')).mkdir(dir, { recursive: true }) } catch { /* ignore */ }
          // Reusable per-app caller workflow
          if (opts.reusable === true) {
            let appPath: string = opts.app && opts.app.length > 0 ? opts.app : ''
            if (!appPath) {
              const resolved = await resolveAppPath({ cwd, ci: true })
              appPath = resolved.path === cwd ? '.' : resolved.path.replace(cwd + (cwd.endsWith('\\') || cwd.endsWith('/') ? '' : (process.platform === 'win32' ? '\\' : '/')), '')
              appPath = appPath.replace(/\\/g, '/')
            }
            const file = join(dir, 'deploy-app-gh-pages.yml')
            const body = `name: Deploy App (GitHub Pages)\n\n` +
`on:\n` +
`  push:\n` +
`    branches: [ main ]\n` +
`  workflow_dispatch:\n\n` +
`permissions:\n` +
`  contents: read\n` +
`  pages: write\n` +
`  id-token: write\n\n` +
`jobs:\n` +
`  deploy:\n` +
`    uses: ./.github/workflows/_reusable-gh-pages.yml\n` +
`    with:\n` +
`      app_path: ${appPath}\n`
            await writeFile(file, body, 'utf8')
            if (jsonMode) { logger.jsonPrint({ ok: true, action: 'generate', provider: 'github', mode: 'reusable', path: file, app_path: appPath, final: true }); return }
            logger.success(`Generated GitHub Pages per-app workflow at ${file}`)
            logger.note(`App: ${appPath}`)
            return
          }
          // Standalone GH Pages workflow (non-reusable)
          const outDir: string = ((): string => {
            const pub = detection.publishDir?.trim()
            if (pub && pub.length > 0) return pub
            const fw = (detection.framework || '').toLowerCase()
            if (fw === 'astro') return 'dist'
            if (fw === 'sveltekit') return 'build'
            if (fw === 'next') return 'out' // requires next export
            return 'dist'
          })()
          const file = join(dir, 'deploy-pages.yml')
          const body = `name: Deploy to GitHub Pages\n\n` +
`on:\n` +
`  push:\n` +
`    branches: [ main ]\n` +
`  workflow_dispatch:\n\n` +
`permissions:\n` +
`  contents: read\n` +
`  pages: write\n` +
`  id-token: write\n\n` +
`jobs:\n` +
`  build:\n` +
`    runs-on: ubuntu-latest\n` +
`    steps:\n` +
`      - uses: actions/checkout@v4\n` +
`      - uses: pnpm/action-setup@v4\n` +
`        with:\n` +
`          version: 9\n` +
`      - uses: actions/setup-node@v4\n` +
`        with:\n` +
`          node-version: 20\n` +
`          cache: 'pnpm'\n` +
`      - run: pnpm install --frozen-lockfile\n` +
`      - run: pnpm run build\n` +
`      - uses: actions/upload-pages-artifact@v3\n` +
`        with:\n` +
`          path: ${outDir}\n` +
`  deploy:\n` +
`    needs: build\n` +
`    runs-on: ubuntu-latest\n` +
`    environment:\n` +
`      name: github-pages\n` +
`      url: ` + '${{ steps.deployment.outputs.page_url }}' + `\n` +
`    steps:\n` +
`      - id: deployment\n` +
`        uses: actions/deploy-pages@v4\n`
          await writeFile(file, body, 'utf8')
          if (jsonMode) { logger.jsonPrint({ ok: true, action: 'generate' as const, provider: 'github' as const, path: file, final: true }); return }
          logger.success(`Generated GitHub Pages workflow at ${file}`)
          if ((detection.framework || '').toLowerCase() === 'next') {
            logger.note('Next.js → GitHub Pages: set next.config output: "export" and run next export to produce out/.')
          }
          return
        }
        if (provider === 'turbo') {
          const path: string = join(cwd, 'turbo.json')
          const exists = async (): Promise<boolean> => { try { const s = await stat(path); return s.isFile() } catch { return false } }
          if (opts.overwrite === true || !(await exists())) {
            const turbo = {
              tasks: {
                build: {
                  dependsOn: ['^build'],
                  outputs: ['.next/**', '!.next/cache/**', 'dist/**']
                }
              }
            }
            await writeFile(path, `${JSON.stringify(turbo, null, 2)}\n`, 'utf8')
          }
          if (jsonMode) {
            logger.jsonPrint({ ok: true, action: 'generate' as const, provider: 'turbo' as const, path, final: true })
            return
          }
          logger.success(`Generated Turborepo config at ${path}`)
          return
        }
        logger.error(`Unknown provider: ${provider}`)
        process.exitCode = 1
      } catch (err) {
        const message: string = err instanceof Error ? err.message : String(err)
        logger.error(message)
        process.exitCode = 1
      }
    })
}
