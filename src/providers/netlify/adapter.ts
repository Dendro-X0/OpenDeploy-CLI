import type { ProviderAdapter } from '../../types/provider-adapter'
import type { DetectionResult } from '../../types/detection-result'
import type { DeployInputs } from '../../types/deploy-inputs'
import type { DeployResult } from '../../types/deploy-result'
import { join } from 'node:path'
import { stat, writeFile, readFile } from 'node:fs/promises'
import { proc } from '../../utils/process'
import { fsx } from '../../utils/fs'

/**
 * Netlify provider adapter (stub for MVP).
 */
export class NetlifyAdapter implements ProviderAdapter {
  public readonly name = 'netlify'
  public async validateAuth(): Promise<void> {
    // Ensure CLI exists
    const ver = await proc.run({ cmd: 'netlify --version' })
    if (!ver.ok) throw new Error('Netlify CLI not available. Install with: npm i -g netlify-cli')
    // Check login status without requiring a linked directory
    const st = await proc.run({ cmd: 'netlify status' })
    if (!st.ok) {
      const msg = (st.stderr + st.stdout).toLowerCase()
      // Not being in a linked folder is fine for deploys when --site is provided
      const unlinked = msg.includes("don't appear to be in a folder that is linked") || msg.includes('not linked')
      const notLogged = msg.includes('not logged in') || msg.includes('please run: netlify login') || msg.includes('run: netlify login')
      if (notLogged) throw new Error('Netlify CLI not logged in. Run: netlify login')
      if (!unlinked) throw new Error('Netlify CLI status failed. Try: netlify login')
    } else {
      const body = st.stdout.toLowerCase()
      if (body.includes('not logged in')) throw new Error('Netlify CLI not logged in. Run: netlify login')
    }
  }
  public async generateConfig(args: { readonly detection: DetectionResult; readonly overwrite: boolean }): Promise<string> {
    const cwd: string = args.detection.rootDir
    const path: string = join(cwd, 'netlify.toml')
    const framework: string = args.detection.framework
    const exists = async (): Promise<boolean> => {
      try { const s = await stat(path); return s.isFile() } catch { return false }
    }
    if (args.overwrite !== true && await exists()) return path
    // Next.js: prefer Netlify Next Runtime (or legacy plugin if runtime not installed)
    if (framework === 'next') {
      const nextManifestPath: string = join(cwd, 'node_modules', '@netlify', 'next', 'manifest.yml')
      const hasNextRuntime: boolean = await fsx.exists(nextManifestPath)
      const pluginPkg: string = hasNextRuntime ? '@netlify/next' : '@netlify/plugin-nextjs'
      const header: string = hasNextRuntime ? '# Uses Netlify Next Runtime for Next.js' : '# Uses legacy Netlify Next plugin'
      const safeBuildCmd: string = 'next build'
      const publish = '.next'
      const toml = `# Auto-generated by OpenDeploy CLI\n${header}\n[build]\n  command = "${safeBuildCmd}"\n  publish = "${publish}"\n  [build.environment]\n    NODE_VERSION = "20"\n\n[[plugins]]\n  package = "${pluginPkg}"\n`
      await writeFile(path, `${toml}`, 'utf8')
      return path
    }
    // Nuxt: publish .output/public and run nuxi build
    if (framework === 'nuxt') {
      const header = '# Auto-generated by OpenDeploy CLI (Nuxt)'
      const safeBuildCmd: string = 'npx nuxi build'
      const publish = '.output/public'
      const toml = `${header}\n[build]\n  command = "${safeBuildCmd}"\n  publish = "${publish}"\n`
      await writeFile(path, toml, 'utf8')
      return path
    }
    // Others: write a minimal static config using detection
    const publishDir: string = args.detection.publishDir ?? 'dist'
    const sanitizedBuild: string = sanitizeBuild(args.detection.buildCommand)
    const header = '# Auto-generated by OpenDeploy CLI'
    const toml = `${header}\n[build]\n  command = "${sanitizedBuild}"\n  publish = "${publishDir}"\n`
    await writeFile(path, toml, 'utf8')
    return path
  }

  public async deploy(inputs: DeployInputs): Promise<DeployResult> {
    const cwd: string = inputs.detection.rootDir
    if (inputs.dryRun) return { url: '', projectId: '' }
    // Use siteId if provided via projectId
    const siteFlag: string = inputs.projectId ? ` --site ${inputs.projectId}` : ''
    const prodFlag: string = inputs.env === 'prod' ? ' --prod' : ''
    const t0: number = Date.now()
    // Build first with the appropriate context, then deploy without rebuilding
    const ctx: string = inputs.env === 'prod' ? 'production' : 'deploy-preview'
    const buildRes = await proc.run({ cmd: `netlify build --context ${ctx}`, cwd })
    if (!buildRes.ok) throw new Error('Netlify build failed')
    const out = await proc.run({ cmd: `netlify deploy --no-build${prodFlag}${siteFlag}`, cwd })
    const durationMs: number = Date.now() - t0
    if (!out.ok) throw new Error(out.stderr.trim() || out.stdout.trim() || 'Netlify deploy failed')
    const url: string = this.extractUrl(out.stdout)
    const logsUrl: string | undefined = this.extractLogsUrl(out.stdout)
    if (url.length === 0) throw new Error('Netlify deploy succeeded but URL not found in output')
    return { url, projectId: inputs.projectId ?? '', provider: 'netlify', target: inputs.env, durationMs, logsUrl }
  }

  public async open(projectId?: string): Promise<void> {
    const cwd: string = process.cwd()
    const siteFlag: string = projectId ? ` --site ${projectId}` : ''
    const out = await proc.run({ cmd: `netlify open${siteFlag}`, cwd })
    if (!out.ok) throw new Error(out.stderr.trim() || out.stdout.trim() || 'Failed to open Netlify dashboard')
  }

  public async logs(args: { readonly projectId?: string; readonly env: 'prod' | 'preview'; readonly follow?: boolean; readonly since?: string; readonly cwd?: string; readonly orgId?: string }): Promise<void> {
    const cwd: string = args.cwd ?? process.cwd()
    const siteFlag: string = args.projectId ? ` --site ${args.projectId}` : ''
    const follow: string = args.follow === true ? ' -f' : ''
    const cmd = `netlify logs${siteFlag}${follow}`
    const ctrl = proc.spawnStream({ cmd, cwd })
    await ctrl.done
  }

  private extractUrl(text: string): string {
    // Netlify CLI prints lines like: "Website URL: https://your-site.netlify.app"
    const m = text.match(/https?:\/\/[^\s]+\.netlify\.app\b/)
    return m?.[0] ?? ''
  }

  private extractLogsUrl(text: string): string | undefined {
    // Look for Netlify dashboard deploys URL, e.g., https://app.netlify.com/sites/<site>/deploys/<dep_...>
    const m = text.match(/https?:\/\/app\.netlify\.com\/sites\/[A-Za-z0-9_-]+\/deploys\/[A-Za-z0-9_-]+/)
    return m?.[0]
  }
}

function sanitizeBuild(build: string | null | undefined): string {
  const raw = (build ?? '').trim()
  if (raw.length === 0) return 'npm run build'
  // Remove prisma operations from Netlify build to avoid DB access in build
  if (/prisma\s+migrate|prisma\s+db\s+push/i.test(raw)) return 'npm run build'
  return raw
}
