import type { ProviderAdapter } from '../../types/provider-adapter'
import type { DetectionResult } from '../../types/detection-result'
import type { DeployInputs } from '../../types/deploy-inputs'
import type { DeployResult } from '../../types/deploy-result'
import { join } from 'node:path'
import { stat, writeFile, readFile } from 'node:fs/promises'
import { proc } from '../../utils/process'
import { fsx } from '../../utils/fs'

/**
 * Netlify provider adapter (stub for MVP).
 */
export class NetlifyAdapter implements ProviderAdapter {
  public readonly name = 'netlify'
  public async validateAuth(): Promise<void> {
    // Ensure CLI exists
    const ver = await proc.run({ cmd: 'netlify --version' })
    if (!ver.ok) throw new Error('Netlify CLI not available. Install with: npm i -g netlify-cli')
    // Check login status without requiring a linked directory
    const st = await proc.run({ cmd: 'netlify status' })
    if (!st.ok) {
      const msg = (st.stderr + st.stdout).toLowerCase()
      // Not being in a linked folder is fine for deploys when --site is provided
      const unlinked = msg.includes("don't appear to be in a folder that is linked") || msg.includes('not linked')
      const notLogged = msg.includes('not logged in') || msg.includes('please run: netlify login') || msg.includes('run: netlify login')
      if (notLogged) throw new Error('Netlify CLI not logged in. Run: netlify login')
      if (!unlinked) throw new Error('Netlify CLI status failed. Try: netlify login')
    } else {
      const body = st.stdout.toLowerCase()
      if (body.includes('not logged in')) throw new Error('Netlify CLI not logged in. Run: netlify login')
    }
  }
  public async generateConfig(args: { readonly detection: DetectionResult; readonly overwrite: boolean }): Promise<string> {
    const cwd: string = args.detection.rootDir
    const path: string = join(cwd, 'netlify.toml')
    // Netlify Next Runtime for Next.js 15+ (preferred). Fallback to legacy plugin if runtime plugin is not present.
    const publish: string = '.next'
    const buildCommand: string | null = args.detection.buildCommand ?? 'next build'
    const nextManifestPath: string = join(cwd, 'node_modules', '@netlify', 'next', 'manifest.yml')
    const hasNextRuntime: boolean = await fsx.exists(nextManifestPath)
    if (args.overwrite !== true) {
      try {
        const s = await stat(path)
        if (s.isFile()) {
          try {
            const buf = await readFile(path, 'utf8')
            const usesRuntime = buf.includes('@netlify/next')
            const usesLegacy = buf.includes('@netlify/plugin-nextjs')
            const hasPrismaInBuild = /build\s*\.[^\n]*command\s*=\s*"[^"]*prisma/i.test(buf) || buf.toLowerCase().includes('prisma migrate')
            if (hasPrismaInBuild) {
              // Rewrite to remove prisma from build command for Netlify
            } else {
            if (usesLegacy && !usesRuntime) return path
            // If file uses runtime but runtime package is missing, rewrite to legacy
            if (usesRuntime && !hasNextRuntime) {
              // fall through to write legacy config below
            } else {
              // Either using runtime with manifest present, or some other custom config; keep it
              return path
            }
            }
          } catch { return path }
        }
      } catch { /* continue to write */ }
    }
    const pluginPkg: string = hasNextRuntime ? '@netlify/next' : '@netlify/plugin-nextjs'
    const header: string = hasNextRuntime ? '# Uses Netlify Next Runtime for Next.js' : '# Uses legacy Netlify Next plugin'
    const safeBuildCmd: string = 'next build'
    const toml = `# Auto-generated by OpenDeploy CLI\n${header}\n[build]\n  command = "${safeBuildCmd}"\n  publish = "${publish}"\n  [build.environment]\n    NODE_VERSION = "20"\n\n[[plugins]]\n  package = "${pluginPkg}"\n`
    await writeFile(path, `${toml}`, 'utf8')
    return path
  }
  public async deploy(inputs: DeployInputs): Promise<DeployResult> {
    const cwd: string = inputs.detection.rootDir
    if (inputs.dryRun) return { url: '', projectId: '' }
    // Use siteId if provided via projectId
    const siteFlag: string = inputs.projectId ? ` --site ${inputs.projectId}` : ''
    const prodFlag: string = inputs.env === 'prod' ? ' --prod' : ''
    const t0: number = Date.now()
    const out = await proc.run({ cmd: `netlify deploy --build${prodFlag}${siteFlag}`, cwd })
    const durationMs: number = Date.now() - t0
    if (!out.ok) throw new Error(out.stderr.trim() || out.stdout.trim() || 'Netlify deploy failed')
    const url: string = this.extractUrl(out.stdout)
    if (url.length === 0) throw new Error('Netlify deploy succeeded but URL not found in output')
    return { url, projectId: inputs.projectId ?? '', provider: 'netlify', target: inputs.env, durationMs }
  }
  public async open(projectId?: string): Promise<void> {
    const cwd: string = process.cwd()
    const siteFlag: string = projectId ? ` --site ${projectId}` : ''
    const out = await proc.run({ cmd: `netlify open${siteFlag}`, cwd })
    if (!out.ok) throw new Error(out.stderr.trim() || out.stdout.trim() || 'Failed to open Netlify dashboard')
  }
  public async logs(args: { readonly projectId?: string; readonly env: 'prod' | 'preview'; readonly follow?: boolean; readonly since?: string; readonly cwd?: string; readonly orgId?: string }): Promise<void> {
    const cwd: string = args.cwd ?? process.cwd()
    const siteFlag: string = args.projectId ? ` --site ${args.projectId}` : ''
    const follow: string = args.follow === true ? ' -f' : ''
    const cmd = `netlify logs${siteFlag}${follow}`
    const ctrl = proc.spawnStream({ cmd, cwd })
    await ctrl.done
  }
  private extractUrl(text: string): string {
    // Netlify CLI prints lines like: "Website URL: https://your-site.netlify.app"
    const m = text.match(/https?:\/\/[^\s]+\.netlify\.app\b/)
    return m?.[0] ?? ''
  }
}
